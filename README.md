基本概念
========

本网关不是一个通用型的网关，它有一套自己的通讯协议，需要配套的客户端和服务端才能使用。

本网关的实现目的有以下几点：

1. 复用客户端网络连接
2. 减少暴露在公网的服务器
3. 提升网络故障转移的效率

通讯协议
=======

基础逻辑：

+ 通讯过程中需要客户端和服务端主动连接到网关
+ 每个客户端只会连接到一个网关，并且只会建立一个物理连接
+ 每个服务端和同一个服务端只会有一个物理连接

拓扑结构：

![Gateway](https://raw.githubusercontent.com/fastgo/gateway/master/gateway.png)

客户端和服务端均采用相同的协议格式与网关进行通讯，消息用以下封包格式传输：

```
+-----------------+--------+
| Length (4 byte) | Packet |
+-----------------+--------+
```

每个消息包的包体可以分解为虚拟连接ID和消息两部分：

```
+------------------+---------+
| Conn ID (4 byte) | Message |
+------------------+---------+
```

`Conn ID`是虚拟连接的唯一标识，网关通过识别`Conn ID`来转发消息。

当`Conn ID`为0时，`Message`的内容被网关进一步解析并作为指令进行处理。

网关指令固定以一个字节的指令类型字段开头，指令参数根据指令类型而定：

```
+--------------+------+
| CMD (1 byte) | Args |
+--------------+------+
```

目前支持的指令如下：

| **指令ID** | **用途** | **上行 Args** | **下行 Args** | **特殊约定** |
| ---- | ---- | ---- | ---- | ---- |
| 1 | 新建虚拟连接 | Server ID / Client ID | Client ID / Server ID + Conn ID | 返回0表示连接失败 |
| 2 | 关闭虚拟连接 | Conn ID | 无 | 无 |
| 3 | 存活检测 | 无 | 无 | 收到后应立即响应 |

特殊说明：

+ 协议不只允许客户端主动连接服务端，也允许服务端主动连接客户端。
+ 新建虚拟连接的时候，网关会把虚拟连接信息发送给两端。

完整的消息示例：

+ 创建虚拟连接到服务端：

	```
	+---------------------+----------------------+------------------+------------------------+
	| Length = 9 (4 byte) | Conn ID = 0 (4 byte) | CMD = 1 (1 byte) | Server ID = 1 (4 byte) |
	+---------------------+----------------------+------------------+------------------------+
	```

+ 网关发送虚拟连接信息给服务端：

	```
	+----------------------+----------------------+------------------+------------------------+-------------------------+
	| Length = 13 (4 byte) | Conn ID = 0 (4 byte) | CMD = 1 (1 byte) | Client ID = 1 (4 byte) | Conn ID = 9527 (4 byte) |
	+----------------------+----------------------+------------------+------------------------+-------------------------+
	```

+ 网关发送虚拟连接信息给客户端：

	```
	+----------------------+----------------------+------------------+------------------------+-------------------------+
	| Length = 13 (4 byte) | Conn ID = 0 (4 byte) | CMD = 1 (1 byte) | Server ID = 1 (4 byte) | Conn ID = 9527 (4 byte) |
	+----------------------+----------------------+------------------+------------------------+-------------------------+
	```

+ 客户端通过虚拟连接发送"Hello"到服务端：

	```
	+---------------------+-------------------------+----------------------------+
	| Length = 9 (4 byte) | Conn ID = 9527 (4 byte) | Message = "Hello" (5 byte) |
	+---------------------+-------------------------+----------------------------+
	```

+ 客户端关闭虚拟连接：

	```
	+---------------------+----------------------+------------------+-------------------------+
	| Length = 9 (4 byte) | Conn ID = 0 (4 byte) | CMD = 2 (1 byte) | Conn ID = 9527 (4 byte) |
	+---------------------+----------------------+------------------+-------------------------+
	```

握手协议
=======

服务端在连接网关时需要先进行握手来验证服务端的合法性。

握手过程如下：

0. 合法的服务端应持有正确的网关秘钥。
1. 网关在接受到新的服务端连接之后，向新连接发送一个`uint64`范围内的随机数作为挑战码。
2. 服务端收到挑战码后，拿出秘钥，计算 `MD5(挑战码 + 秘钥)`，得到验证码。
3. 服务端将验证码和自身节点ID一起发送给网关。
4. 网关收到消息后同样计算 `MD5(挑战码 + 秘钥)`，跟收到的验证码比对是否一致。
5. 验证码比对一致，网关将新连接登记为对应节点ID的连接。

握手下行数据格式：

```
+-------------------------+
| Challenge Code (8 byte) |
+-------------------------+
```

握手上行数据格式：

```
+---------------+--------------------+
| MD5 (16 byte) | Server ID (4 byte) |
+---------------+--------------------+
```
