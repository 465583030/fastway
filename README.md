基本概念
========

本网关不是一个通用型的网关，它有一套自己的通讯协议，需要配套的客户端和服务端才能使用。

本网关的实现目的有以下几点：

1. 复用客户端网络连接
2. 减少暴露在公网的服务器
3. 提升网络故障转移的效率

通讯协议
=======

基础逻辑：

+ 通讯过程中需要客户端和服务端主动连接到网关
+ 每个客户端只会连接到一个网关，并且只会建立一个物理连接
+ 每个服务端和同一个服务端只会有一个物理连接

拓扑结构：

![Gateway](https://raw.githubusercontent.com/fastgo/gateway/master/gateway.png)

客户端和服务端均采用相同的协议与网关进行通讯，数值均采用小端编码。

消息使用的是定长包头的分包协议传输，包头的4个字节存储包体长度信息：

```
+-----------------+--------+
| Length (4 byte) | Packet |
+-----------------+--------+
```

包体固定以客户端ID开头：

```
         +--------------------+---------+
Packet = | Client ID (4 byte) | Message |
         +--------------------+---------+
```

当客户端ID小于`max(uint32)`时，消息由服务端ID和消息内容两部分组成：

```
if ClientID < MaxUint32
{
              +--------------------+---------+
    Message = | Server ID (4 byte) | Content |
              +--------------------+---------+
}
```

网关使用客户端ID和服务端ID来建立并维护虚拟连接，虚拟连接在两端首次通讯时自动建立。

发送空消息用来显式的关闭虚拟连接，客户端、网关、服务端三者都可能主动发出关闭消息。

由客户端创建的虚拟连接不再使用时需要显式关闭，否则可能会触发网关对单个客户端的虚拟连接数限制。

当客户端ID为`max(uint32)`时，消息的内容被一步解析并作为指令进行处理。

指令消息固定以一个字节的指令类型字段开头，指令参数根据指令类型而定：

```
if ClientID == MaxUint32 
{
              +--------------+------+
    Message = | CMD (1 byte) | Args |
              +--------------+------+
}
```

目前支持的指令如下：

| **指令ID** | **用途** | **上行 Args** | **下行 Args** | **特殊约定** |
| ---- | ---- | ---- | ---- | ---- |
| 1 | 存活检测 | 无 | 无 | 收到后应立即响应 |

完整的消息示例：

+ 客户端(11)通过虚拟连接发送"Hello"到服务端(22)：

	```
	+----------------------+-------------------------+-------------------------+----------------------------+
	| Length = 13 (4 byte) | Client ID = 11 (4 byte) | Server ID = 22 (4 byte) | Message = "Hello" (5 byte) |
	+----------------------+-------------------------+-------------------------+----------------------------+
	```

+ 网关发送PING指令：

	```
	+---------------------+---------------------------------+------------------+
	| Length = 8 (5 byte) | Client ID = 0xFFFFFFFF (4 byte) | CMD = 1 (1 byte) |
	+---------------------+---------------------------------+------------------+
	```

+ 客户端关闭虚拟连接：

	```
	+---------------------+-------------------------+-------------------------+
	| Length = 8 (4 byte) | Client ID = 11 (4 byte) | Server ID = 22 (4 byte) |
	+---------------------+-------------------------+-------------------------+
	```

握手协议
=======

服务端在连接网关时需要先进行握手来验证服务端的合法性。

握手过程如下：

0. 合法的服务端应持有正确的网关秘钥。
1. 网关在接受到新的服务端连接之后，向新连接发送一个`uint64`范围内的随机数作为挑战码。
2. 服务端收到挑战码后，拿出秘钥，计算 `MD5(挑战码 + 秘钥)`，得到验证码。
3. 服务端将验证码和自身节点ID一起发送给网关。
4. 网关收到消息后同样计算 `MD5(挑战码 + 秘钥)`，跟收到的验证码比对是否一致。
5. 验证码比对一致，网关将新连接登记为对应节点ID的连接。

握手下行数据格式：

```
+-------------------------+
| Challenge Code (8 byte) |
+-------------------------+
```

握手上行数据格式：

```
+---------------+--------------------+
| MD5 (16 byte) | Server ID (4 byte) |
+---------------+--------------------+
```
