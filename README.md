基本概念
========

本网关不是一个通用型的网关，它只支持一种分包协议，有一套自己的通讯协议，需要配套的客户端和服务端才能使用。

本网关的设计目的有以下几点：

1. 复用客户端网络连接
2. 减少暴露在公网的服务器
3. 提升网络故障转移的效率

网关采用的是被动式的设计，需要客户端和服务端主动连接到网关。

客户端和网关之间，以及服务端跟网关之间，都只会建立一个物理连接。

![Gateway](https://raw.githubusercontent.com/fastgo/gateway/master/gateway.png)

虚拟连接
========

因为客户端到网关只有一个物理连接，但业务场景中往往需要客户端跟多个服务端进行通讯。而从服务端的角度，也是用一个物理连接和网关通讯，服务端需要能从这个物理连接传输过来的数据中分辨出数据属于哪个客户端连接。

所以需要在物理连接基础上构建虚拟连接，虚拟连接的用例：

+ 客户端为每个连接过的服务端维护一个自增的虚拟连接ID（`Conn ID`）。
+ 客户端向目标服务端发送消息时，将`{Server ID, Conn ID}`附加在消息的包头发送给网关。
+ 网关通过识别包头的`{Server ID}`来找到对应的服务端物理连接，并将`{Client ID, Conn ID}`附加在消息的包头发送给服务端。
+ 服务端通过`{Gateway ID, Client ID, Conn ID}`来对识别虚拟连接。
+ 当服务端对客户端发送消息时，将`{Client ID, Conn ID}`附加在消息的包头发送给网关。
+ 网关通过识别包头的`{Client ID}`来找到对应的客户端物理连接，并将`{Server ID, Conn ID}`附加在消息的包头发送给服务端。
+ 客户端通过包头的`{Server ID, Conn ID}`信息来识别下行消息的目标虚拟连接。

重连协议
========

本网关支持断线重连，基本逻辑是：

+ 网关缓存最近发送的N个消息（可设置）。
+ 网关和客户端各自对发送的消息和接收的消息进行计算。
+ 当进行重连时，双方互发已接收消息数。
+ 双发通过计算对方已收消息数据和本地的已发消息数据来补发对方没有收到的消息。

为了降低缓存的内存占用和对象数量，协议要求双发发送消息时，附带自己距离上次发送消息到这次之间所接收到的消息数，网关拿已接收消息数和已发送消息数对比，丢弃缓存中不需要重发的消息。

为了确保重连机制不会被恶意利用，客户端和服务端在连接到网关以后，网关会下发当前物理连接ID和一个用于将来验证重连用的密钥，之后在重连的时候，通过回发这两个信息来验证重连的合法性。

为了进一步提升系统的安全性，避免恶意的轮询连接ID和密钥值，协议中加入`MD5(连接ID + 重连密钥 + 签名密钥)`计算出来的签名信息来验证重连信息的合法性，确保重连信息是本网关生成的。

重连上下行格式：

```
+-------------+--------------+---------------+-------------------+
| ID (8 byte) | Key (8 byte) | MD5 (16 byte) | Recv Num (4 byte) |
+-------------+--------------+---------------+-------------------+
```

特殊约定：

+ 当上行数据中`{ID = 0}`时，表示新建连接
+ 当下行数据中`{ID = 0}`时，表示重连失败

客户端协议
==========

上下行格式：

```
+-------------------+--------------------+------------------+------------------------+--------+
| Recv Num (2 byte) | Server ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+-------------------+--------------------+------------------+------------------------+--------+
```

特殊约定：

+ `Recv Num`为据上次消息到这次消息之间的差值，不是重连时所用的总值。
+ `Packet Length`为0的消息用来表示`Conn ID`失效。
+ `{Server ID = max(uint32), Conn ID = 0}`的消息用来进行存活检查，客户端收到此消息后应该立即回应。

服务端端协议
============

服务端在连接网关时，如果时新建连接，需要执行额外握手协议来验证服务端的合法性。

握手过程：

0. 合法的服务端应持有正确的网关秘钥。
1. 网关在接受到新的服务端连接之后，向新连接发送一个`uint64`范围内的随机数作为挑战码。
2. 服务端收到挑战码后，拿出秘钥，计算 `MD5(挑战码 + 秘钥)`，得到验证码。
3. 服务端将验证码和自身节点ID一起发送给网关。
4. 网关收到消息后同样计算 `MD5(挑战码 + 秘钥)`，跟收到的验证码比对是否一致。
5. 验证码比对一致，网关将新连接登记为对应节点ID的连接。

握手下行格式：

```
+-------------------------+
| Challenge Code (8 byte) |
+-------------------------+
```

握手上行格式：

```
+---------------+--------------------+
| MD5 (16 byte) | Server ID (4 byte) |
+---------------+--------------------+
```

上下行格式：

```
+-------------------+--------------------+------------------+------------------------+--------+
| Recv Num (2 byte) | Client ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+-------------------+--------------------+------------------+------------------------+--------+
```

特殊约定：

+ `Recv Num`为据上次消息到这次消息之间的差值，不是重连时所用的总值。
+ `Packet Length`为0的消息用来表示`Conn ID`无效。
+ `{Client ID = max(uint32), Conn ID = 0}`的消息用来进行存活检查，服务端收到此消息后应该立即回应相同的消息。

优化细节
=======

网关为每个客户端连接分配一个`Receive Buffer`，只有当`Receive Buffer`容量不足以装下将要读取的消息时才会重新申请内存。

对于同一个客户端，网关每次只为其转发一个消息，消息还没转发成功时不会读取后续消息，所以`Receive Buffer`是被顺序使用的，并且可以被重复使用。

协议设计时有意的对齐前端上行消息和后端上行消息格式：

```
+-------------------+--------------------+------------------+------------------------+--------+
| Recv Num (2 byte) | Server ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+-------------------+--------------------+------------------+------------------------+--------+

+-------------------+--------------------+------------------+------------------------+--------+
| Recv Num (2 byte) | Client ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+-------------------+--------------------+------------------+------------------------+--------+
```

读取完整前端消息后，将`Receive Buffer`中的`Server ID`填充为当前客户端的`Client ID`就可以直接发送给服务端，不需要数据拷贝。
