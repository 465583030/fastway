基本概念
========

本网关不是一个通用型的网关，它只支持一种分包协议，有一套自己的通讯协议，需要有配套的客户端和服务端才能使用。

本网关的设计目的有以下几点：

1. 复用客户端网络连接
2. 减少暴露在公网的服务器
3. 提升网络故障转移的效率

网关采用的是被动式的设计，需要客户端和服务端主动连接到网关。

客户端和网关之间以及服务端跟网关之间，都只会建立一个物理连接。

网关通过识别消息包头的目标服务端ID和目标客户端ID来转发消息。

服务端通过识别包头的来源客户端ID来区分客户端。

网关不会维护虚拟连接的状态，只负责消息转发，虚拟连接的管理由客户端和服务端各自负责。

客户端为每个连接过的服务端维护一个顺序自增的版本号，用于区别对同一个服务端的不同连接。

这个版本号会附在上行消息包头连同客户端ID一起发送到服务端，也会附在下行消息包头连同服务端ID一起发送到客户端。

版本号的加入虽然可以起到让一个客户端对同一个服务端建立多个虚拟连接的作用，但这不是加入版本号的目的。

加入版本号的目的是为了在临界情况下，客户端和服务端可以正确的处理失效的连接。

前端协议
=======

上下行：

```
+--------------------+------------------+------------------------+--------+
| Server ID (4 byte) | Version (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+
```

特殊约定：

+ `Packet Length`为0的消息用来表示`Version`失效。
+ `{Server ID = max(uint32), Version = 0}`的消息用来进行存活检查，客户端收到此消息后应该立即回应相同的消息。

后端协议
=======

握手过程：

0. 合法的服务端应持有正确的网关秘钥
1. 网关在接受到新的服务端连接之后，向新连接发送一个`uint64`范围内的随机数作为挑战码
2. 服务端收到挑战码后，拿出秘钥，计算 `MD5(挑战码 + 秘钥)`，得到验证码
3. 服务端将验证码和自身节点ID一起发送给网关
4. 网关收到消息后同样计算 `MD5(挑战码 + 秘钥)`，跟收到的验证码比对是否一致
5. 验证码比对一致，网关将新连接登记为对应节点ID的连接

握手下行：

```
+-------------------------+
| Challenge Code (8 byte) |
+-------------------------+
```

握手上行：

```
+------------------------------------+
| MD5 (16 byte) | Server ID (4 byte) |
+------------------------------------+
```

上下行：

```
+--------------------+------------------+------------------------+--------+
| Client ID (4 byte) | Version (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+
```

特殊约定：

+ `Packet Length`为0的消息用来表示`Conn ID`无效。
+ `{Client ID = max(uint32), Version = 0}`的消息用来进行存活检查，服务端收到此消息后应该立即回应相同的消息。

优化细节
=======

网关为每个客户端连接分配一个`Receive Buffer`，只有当`Receive Buffer`容量不足以装下将要读取的消息时才会重新申请内存。

对于同一个客户端，网关每次只为其转发一个消息，消息还没转发成功时不会读取后续消息，所以`Receive Buffer`是被顺序使用的，并且可以被重复使用。

协议设计时有意的对齐前端上行消息和后端上行消息格式：

```
+--------------------+------------------+------------------------+--------+
| Server ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+

+--------------------+------------------+------------------------+--------+
| Client ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+
```

读取完整前端消息后，将`Receive Buffer`中的`Server ID`填充为当前客户端的`Client ID`就可以直接发送给服务端，不需要数据拷贝。
