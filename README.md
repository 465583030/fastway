基本概念
========

本网关不是一个通用型的网关，它只支持一种分包协议，有一套自己的通讯协议，需要配套的客户端和服务端才能使用。

本网关的设计目的有以下几点：

1. 复用客户端网络连接
2. 减少暴露在公网的服务器
3. 提升网络故障转移的效率

网关采用的是被动式的设计，需要客户端和服务端主动连接到网关。

客户端和网关之间，以及服务端跟网关之间，都只会建立一个物理连接。

![Gateway](https://raw.githubusercontent.com/fastgo/gateway/master/gateway.png)

客户端为每个连接过的服务端维护一个自增的虚拟连接ID（`Conn ID`）。

客户端向目标服务端发送消息时，将`{Server ID, Conn ID}`附加在消息的包头发送给网关。

网关通过识别包头的`{Server ID}`来找到对应的服务端物理连接，并将`{Client ID, Conn ID}`附加在消息的包头发送给服务端。

服务端通过`{Gateway ID, Client ID, Conn ID}`来对识别虚拟连接。

当服务端对客户端发送消息时，将`{Client ID, Conn ID}`附加在消息的包头发送给网关。

网关通过识别包头的`{Client ID}`来找到对应的客户端物理连接，并将`{Server ID, Conn ID}`附加在消息的包头发送给服务端。

客户端通过包头的`{Server ID, Conn ID}`信息来识别下行消息的目标虚拟连接。

前端协议
=======

上下行：

```
+--------------------+------------------+------------------------+--------+
| Server ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+
```

特殊约定：

+ `Packet Length`为0的消息用来表示`Conn ID`失效。
+ `{Server ID = max(uint32), Conn ID = 0}`的消息用来进行存活检查，客户端收到此消息后应该立即回应相同的消息。

后端协议
=======

握手过程：

0. 合法的服务端应持有正确的网关秘钥
1. 网关在接受到新的服务端连接之后，向新连接发送一个`uint64`范围内的随机数作为挑战码
2. 服务端收到挑战码后，拿出秘钥，计算 `MD5(挑战码 + 秘钥)`，得到验证码
3. 服务端将验证码和自身节点ID一起发送给网关
4. 网关收到消息后同样计算 `MD5(挑战码 + 秘钥)`，跟收到的验证码比对是否一致
5. 验证码比对一致，网关将新连接登记为对应节点ID的连接

握手下行：

```
+-------------------------+
| Challenge Code (8 byte) |
+-------------------------+
```

握手上行：

```
+------------------------------------+
| MD5 (16 byte) | Server ID (4 byte) |
+------------------------------------+
```

上下行：

```
+--------------------+------------------+------------------------+--------+
| Client ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+
```

特殊约定：

+ `Packet Length`为0的消息用来表示`Conn ID`无效。
+ `{Client ID = max(uint32), Conn ID = 0}`的消息用来进行存活检查，服务端收到此消息后应该立即回应相同的消息。

优化细节
=======

网关为每个客户端连接分配一个`Receive Buffer`，只有当`Receive Buffer`容量不足以装下将要读取的消息时才会重新申请内存。

对于同一个客户端，网关每次只为其转发一个消息，消息还没转发成功时不会读取后续消息，所以`Receive Buffer`是被顺序使用的，并且可以被重复使用。

协议设计时有意的对齐前端上行消息和后端上行消息格式：

```
+--------------------+------------------+------------------------+--------+
| Server ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+

+--------------------+------------------+------------------------+--------+
| Client ID (4 byte) | Conn ID (1 byte) | Packet Length (4 byte) | Packet |
+--------------------+------------------+------------------------+--------+
```

读取完整前端消息后，将`Receive Buffer`中的`Server ID`填充为当前客户端的`Client ID`就可以直接发送给服务端，不需要数据拷贝。
